"""
J.A.R.V.I.S. Medical OCR System
Advanced OCR pipeline for prescription and lab result processing
"""

import os
import sys
import cv2
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
import json
import re
from datetime import datetime

# OCR Libraries
try:
    import pytesseract
    TESSERACT_AVAILABLE = True
except ImportError:
    print("Warning: Tesseract not available. Install pytesseract for OCR functionality.")
    TESSERACT_AVAILABLE = False

# Image processing
from PIL import Image, ImageEnhance, ImageFilter
import requests
from io import BytesIO

# Import healthcare database
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from Healthcare.Database.models import HealthcareDatabase

class MedicalOCR:
    \"\"\"\n    Medical OCR engine for processing prescriptions and lab results\n    \"\"\"\n    \n    def __init__(self):\n        self.healthcare_db = HealthcareDatabase()\n        \n        # Configure Tesseract if available\n        if TESSERACT_AVAILABLE:\n            # Set Tesseract path for Windows (adjust as needed)\n            if os.name == 'nt':  # Windows\n                tesseract_paths = [\n                    r'C:\\Program Files\\Tesseract-OCR\\tesseract.exe',\n                    r'C:\\Program Files (x86)\\Tesseract-OCR\\tesseract.exe',\n                    r'C:\\Users\\' + os.getenv('USERNAME') + r'\\AppData\\Local\\Programs\\Tesseract-OCR\\tesseract.exe'\n                ]\n                \n                for path in tesseract_paths:\n                    if os.path.exists(path):\n                        pytesseract.pytesseract.tesseract_cmd = path\n                        break\n        \n        # Medical terminology patterns\n        self.medication_patterns = {\n            'dosage': r'(\\d+(?:\\.\\d+)?\\s*(?:mg|g|ml|mcg|units?|tablets?|capsules?))',\n            'frequency': r'((?:once|twice|thrice|\\d+\\s*times?)\\s*(?:daily|per day|a day|every \\d+ hours?))',\n            'duration': r'(for \\d+\\s*(?:days?|weeks?|months?))',\n            'medication_name': r'([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*(?:\\s+\\d+(?:mg|g|ml|mcg))?)',\n            'instructions': r'(take with (?:food|water|meals)|before (?:meals|bedtime)|after (?:meals|food))',\n        }\n        \n        # Lab test patterns\n        self.lab_patterns = {\n            'hemoglobin': r'(?:hemoglobin|hb|hgb)\\s*:?\\s*(\\d+(?:\\.\\d+)?)\\s*(?:g/dl|g\\/dl)?',\n            'blood_pressure': r'(?:bp|blood pressure)\\s*:?\\s*(\\d+)\\s*\\/\\s*(\\d+)',\n            'glucose': r'(?:glucose|sugar)\\s*:?\\s*(\\d+(?:\\.\\d+)?)\\s*(?:mg/dl|mg\\/dl)?',\n            'protein': r'(?:protein|albumin)\\s*:?\\s*(\\d+(?:\\.\\d+)?)\\s*(?:g/dl|g\\/dl|mg/dl|mg\\/dl)?',\n            'cholesterol': r'(?:cholesterol|chol)\\s*:?\\s*(\\d+(?:\\.\\d+)?)\\s*(?:mg/dl|mg\\/dl)?',\n        }\n        \n        print(\"âœ… Medical OCR system initialized\")\n    \n    def preprocess_image(self, image_path: str) -> np.ndarray:\n        \"\"\"\n        Preprocess image for better OCR accuracy\n        \"\"\"\n        try:\n            # Load image\n            if isinstance(image_path, str):\n                image = cv2.imread(image_path)\n            else:\n                image = image_path\n            \n            if image is None:\n                raise ValueError(\"Could not load image\")\n            \n            # Convert to grayscale\n            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n            \n            # Apply noise reduction\n            denoised = cv2.medianBlur(gray, 3)\n            \n            # Enhance contrast\n            clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n            enhanced = clahe.apply(denoised)\n            \n            # Apply threshold\n            _, thresh = cv2.threshold(enhanced, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n            \n            # Morphological operations to clean up\n            kernel = np.ones((1,1), np.uint8)\n            cleaned = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)\n            \n            return cleaned\n            \n        except Exception as e:\n            print(f\"Error preprocessing image: {e}\")\n            # Return original image if preprocessing fails\n            try:\n                return cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n            except:\n                return None\n    \n    def extract_text_from_image(self, image_path: str) -> str:\n        \"\"\"\n        Extract text from image using OCR\n        \"\"\"\n        if not TESSERACT_AVAILABLE:\n            return \"OCR functionality not available. Please install pytesseract.\"\n        \n        try:\n            # Preprocess image\n            processed_image = self.preprocess_image(image_path)\n            \n            if processed_image is None:\n                return \"Could not process image\"\n            \n            # Configure Tesseract for medical text\n            custom_config = r'--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,:-/()+ '\n            \n            # Extract text\n            extracted_text = pytesseract.image_to_string(processed_image, config=custom_config)\n            \n            # Clean up extracted text\n            cleaned_text = self._clean_ocr_text(extracted_text)\n            \n            return cleaned_text\n            \n        except Exception as e:\n            print(f\"Error extracting text from image: {e}\")\n            return f\"Error processing image: {str(e)}\"\n    \n    def _clean_ocr_text(self, text: str) -> str:\n        \"\"\"\n        Clean and normalize OCR extracted text\n        \"\"\"\n        try:\n            # Remove extra whitespace\n            cleaned = re.sub(r'\\s+', ' ', text)\n            \n            # Remove special characters that commonly appear in OCR errors\n            cleaned = re.sub(r'[|\\\\@#$%^&*_+=\\[\\]{};<>?~`]', '', cleaned)\n            \n            # Fix common OCR mistakes\n            replacements = {\n                '0': 'O',  # In medication names\n                'l': '1',  # In dosages\n                'S': '5',  # In numbers\n                'B': '8',  # In numbers\n            }\n            \n            # Apply replacements contextually\n            lines = cleaned.split('\\n')\n            corrected_lines = []\n            \n            for line in lines:\n                if line.strip():\n                    corrected_lines.append(line.strip())\n            \n            return '\\n'.join(corrected_lines)\n            \n        except Exception as e:\n            print(f\"Error cleaning OCR text: {e}\")\n            return text\n    \n    def parse_prescription(self, image_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Parse prescription image and extract medication information\n        \"\"\"\n        try:\n            # Extract text from image\n            ocr_text = self.extract_text_from_image(image_path)\n            \n            if \"Error\" in ocr_text or \"not available\" in ocr_text:\n                return {\n                    'success': False,\n                    'error': ocr_text,\n                    'medications': []\n                }\n            \n            # Parse medications from text\n            medications = self._extract_medications_from_text(ocr_text)\n            \n            # Store in database\n            if medications:\n                prescription_id = self.healthcare_db.add_prescription(\n                    patient_id=1,  # Default patient\n                    image_path=image_path,\n                    ocr_text=ocr_text,\n                    parsed_medications={'medications': medications}\n                )\n                \n                result = {\n                    'success': True,\n                    'prescription_id': prescription_id,\n                    'ocr_text': ocr_text,\n                    'medications': medications,\n                    'medication_count': len(medications)\n                }\n            else:\n                result = {\n                    'success': False,\n                    'error': 'No medications found in prescription',\n                    'ocr_text': ocr_text,\n                    'medications': []\n                }\n            \n            return result\n            \n        except Exception as e:\n            print(f\"Error parsing prescription: {e}\")\n            return {\n                'success': False,\n                'error': f\"Error processing prescription: {str(e)}\",\n                'medications': []\n            }\n    \n    def _extract_medications_from_text(self, text: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Extract medication information from OCR text\n        \"\"\"\n        medications = []\n        \n        try:\n            lines = text.split('\\n')\n            current_medication = {}\n            \n            for line in lines:\n                line = line.strip()\n                if not line:\n                    continue\n                \n                # Look for medication name (usually starts with capital letter)\n                if re.match(r'^[A-Z][a-z]+', line) and not any(word in line.lower() for word in ['dr.', 'hospital', 'clinic', 'patient']):\n                    # Save previous medication if exists\n                    if current_medication and 'name' in current_medication:\n                        medications.append(current_medication.copy())\n                    \n                    # Start new medication\n                    current_medication = {\n                        'name': self._extract_medication_name(line),\n                        'dosage': self._extract_dosage(line),\n                        'frequency': self._extract_frequency(line),\n                        'duration': self._extract_duration(line),\n                        'instructions': self._extract_instructions(line)\n                    }\n                \n                else:\n                    # Look for additional information in subsequent lines\n                    if current_medication:\n                        if not current_medication.get('dosage'):\n                            current_medication['dosage'] = self._extract_dosage(line)\n                        if not current_medication.get('frequency'):\n                            current_medication['frequency'] = self._extract_frequency(line)\n                        if not current_medication.get('duration'):\n                            current_medication['duration'] = self._extract_duration(line)\n                        if not current_medication.get('instructions'):\n                            current_medication['instructions'] = self._extract_instructions(line)\n            \n            # Add last medication\n            if current_medication and 'name' in current_medication:\n                medications.append(current_medication)\n            \n            # Filter out incomplete medications\n            valid_medications = []\n            for med in medications:\n                if med.get('name') and (med.get('dosage') or med.get('frequency')):\n                    # Set defaults for missing fields\n                    med['dosage'] = med.get('dosage') or 'As prescribed'\n                    med['frequency'] = med.get('frequency') or 'As directed'\n                    med['duration'] = med.get('duration') or 'As prescribed'\n                    med['instructions'] = med.get('instructions') or 'Take as directed'\n                    valid_medications.append(med)\n            \n            return valid_medications\n            \n        except Exception as e:\n            print(f\"Error extracting medications from text: {e}\")\n            return []\n    \n    def _extract_medication_name(self, text: str) -> Optional[str]:\n        \"\"\"Extract medication name from text\"\"\"\n        match = re.search(self.medication_patterns['medication_name'], text)\n        return match.group(1) if match else None\n    \n    def _extract_dosage(self, text: str) -> Optional[str]:\n        \"\"\"Extract dosage information from text\"\"\"\n        match = re.search(self.medication_patterns['dosage'], text, re.IGNORECASE)\n        return match.group(1) if match else None\n    \n    def _extract_frequency(self, text: str) -> Optional[str]:\n        \"\"\"Extract frequency information from text\"\"\"\n        match = re.search(self.medication_patterns['frequency'], text, re.IGNORECASE)\n        return match.group(1) if match else None\n    \n    def _extract_duration(self, text: str) -> Optional[str]:\n        \"\"\"Extract duration information from text\"\"\"\n        match = re.search(self.medication_patterns['duration'], text, re.IGNORECASE)\n        return match.group(1) if match else None\n    \n    def _extract_instructions(self, text: str) -> Optional[str]:\n        \"\"\"Extract special instructions from text\"\"\"\n        match = re.search(self.medication_patterns['instructions'], text, re.IGNORECASE)\n        return match.group(1) if match else None\n    \n    def parse_lab_results(self, image_path: str) -> Dict[str, Any]:\n        \"\"\"\n        Parse lab results image and extract test values\n        \"\"\"\n        try:\n            # Extract text from image\n            ocr_text = self.extract_text_from_image(image_path)\n            \n            if \"Error\" in ocr_text or \"not available\" in ocr_text:\n                return {\n                    'success': False,\n                    'error': ocr_text,\n                    'results': {}\n                }\n            \n            # Parse lab values from text\n            lab_results = self._extract_lab_values_from_text(ocr_text)\n            \n            # Analyze for critical values\n            flagged_values = self._analyze_lab_results(lab_results)\n            \n            # Store in database\n            if lab_results:\n                result_id = self.healthcare_db.add_lab_result(\n                    patient_id=1,  # Default patient\n                    test_date=datetime.now().strftime(\"%Y-%m-%d\"),\n                    test_type=\"General Lab Work\",\n                    results=lab_results,\n                    flagged_values=flagged_values,\n                    urgency_level=\"critical\" if flagged_values else \"normal\"\n                )\n                \n                return {\n                    'success': True,\n                    'result_id': result_id,\n                    'ocr_text': ocr_text,\n                    'results': lab_results,\n                    'flagged_values': flagged_values,\n                    'urgency_level': \"critical\" if flagged_values else \"normal\"\n                }\n            else:\n                return {\n                    'success': False,\n                    'error': 'No lab values found in image',\n                    'ocr_text': ocr_text,\n                    'results': {}\n                }\n            \n        except Exception as e:\n            print(f\"Error parsing lab results: {e}\")\n            return {\n                'success': False,\n                'error': f\"Error processing lab results: {str(e)}\",\n                'results': {}\n            }\n    \n    def _extract_lab_values_from_text(self, text: str) -> Dict[str, float]:\n        \"\"\"Extract lab values from OCR text\"\"\"\n        results = {}\n        \n        try:\n            text_lower = text.lower()\n            \n            # Extract each type of lab value\n            for test_name, pattern in self.lab_patterns.items():\n                match = re.search(pattern, text_lower, re.IGNORECASE)\n                if match:\n                    if test_name == 'blood_pressure':\n                        # Special handling for blood pressure (systolic/diastolic)\n                        systolic = float(match.group(1))\n                        diastolic = float(match.group(2))\n                        results['blood_pressure_systolic'] = systolic\n                        results['blood_pressure_diastolic'] = diastolic\n                        results['blood_pressure'] = f\"{systolic}/{diastolic}\"\n                    else:\n                        try:\n                            value = float(match.group(1))\n                            results[test_name] = value\n                        except ValueError:\n                            continue\n            \n            return results\n            \n        except Exception as e:\n            print(f\"Error extracting lab values: {e}\")\n            return {}\n    \n    def _analyze_lab_results(self, lab_results: Dict[str, Any]) -> Dict[str, str]:\n        \"\"\"Analyze lab results for critical values\"\"\"\n        flagged = {}\n        \n        # Normal ranges for pregnancy (these should be configurable)\n        normal_ranges = {\n            'hemoglobin': {'min': 11.0, 'max': 14.0, 'unit': 'g/dL'},\n            'glucose': {'min': 70, 'max': 140, 'unit': 'mg/dL'},\n            'protein': {'min': 6.0, 'max': 8.3, 'unit': 'g/dL'},\n            'blood_pressure_systolic': {'min': 90, 'max': 140, 'unit': 'mmHg'},\n            'blood_pressure_diastolic': {'min': 60, 'max': 90, 'unit': 'mmHg'},\n        }\n        \n        try:\n            for test, value in lab_results.items():\n                if test in normal_ranges and isinstance(value, (int, float)):\n                    range_info = normal_ranges[test]\n                    \n                    if value < range_info['min']:\n                        flagged[test] = f\"Below normal range ({value} < {range_info['min']} {range_info['unit']})\"\n                    elif value > range_info['max']:\n                        flagged[test] = f\"Above normal range ({value} > {range_info['max']} {range_info['unit']})\"\n            \n            return flagged\n            \n        except Exception as e:\n            print(f\"Error analyzing lab results: {e}\")\n            return {}\n    \n    def process_image_from_camera(self, camera_index: int = 0) -> str:\n        \"\"\"Capture image from camera and process it\"\"\"\n        try:\n            # This would integrate with camera capture\n            # For now, return instruction message\n            return \"Camera integration not implemented yet. Please upload an image file instead.\"\n            \n        except Exception as e:\n            print(f\"Error processing camera image: {e}\")\n            return f\"Error accessing camera: {str(e)}\"\n\n# Global instance\nmedical_ocr = MedicalOCR()\n\n# Utility functions for integration\ndef process_prescription_image(image_path: str) -> Dict[str, Any]:\n    \"\"\"Process prescription image and return results\"\"\"\n    return medical_ocr.parse_prescription(image_path)\n\ndef process_lab_results_image(image_path: str) -> Dict[str, Any]:\n    \"\"\"Process lab results image and return results\"\"\"\n    return medical_ocr.parse_lab_results(image_path)\n\ndef extract_text_from_medical_image(image_path: str) -> str:\n    \"\"\"Extract text from any medical image\"\"\"\n    return medical_ocr.extract_text_from_image(image_path)